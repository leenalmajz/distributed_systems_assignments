import joblib, time, datetime, os
from mpi4py import MPI
from queue_mngr import QueueManager
from config import load_config
from models import Message, Transaction, Result # <--- ADDED: Message, Transaction, Result imports
import secrets # For generating unique IDs

class MLService():
    def __init__(self, queue_manager: QueueManager, model_path: str):
        self.comm = MPI.COMM_WORLD
        self.rank = self.comm.Get_rank()    # Gets the ranks of the processes: 0 = master, anything else is a worker process
        self.size = self.comm.Get_size()    # Number of processors is the number of worker processors. Set to 5 as default in the docker-compose.yml
        self.queue_manager = queue_manager
        self.model = self.load_model(model_path)    # Loads the pre-trained model

        if self.rank == 0:
            print(f"Master initialized with {self.size-1} workers")
        else:
            print(f"Worker {self.rank} ready")
        
    def load_model(self, model_path: str):  # Loads the pre-trained model from the pkl file
        if self.rank == 0:
            if not os.path.exists(model_path):
                raise FileNotFoundError(f"Model file {model_path} not found.")
            return joblib.load(model_path)

    def process_transactions(self, transactions_queue = 'transactions', results_queue  = 'results'):
        print(self.rank)
        if self.rank == 0:  # Master process
            while True:
                transactions_to_process = []
                for _ in range(self.size): # Try to pull as many transactions as processes available
                    transaction_data_dict = self.queue_manager.pull(transactions_queue)
                    if transaction_data_dict:
                        transactions_to_process.append(transaction_data_dict)
                        print(f"Master pulled transaction: {transaction_data_dict.get('transaction_id')}")
                    else:
                        print(f"Master: No more transactions in queue {transactions_queue}. Breaking from pull loop.")
                        break # No more messages in queue

                if not transactions_to_process:
                    print("Master: Transaction queue empty. Waiting for a moment...")
                    time.sleep(2) # Wait if queue is empty
                    continue # Continue to next iteration of while True to recheck

                # Distribute transactions to workers (rank 1 to size-1)
                # Ensure we don't try to send more than available workers and transactions
                num_workers_available = self.size - 1
                for i in range(min(len(transactions_to_process), num_workers_available)):
                    dest_rank = i + 1
                    transaction = transactions_to_process[i]
                    print(f"Master sending transaction {transaction.get('transaction_id')} to worker {dest_rank}")
                    self.comm.send(transaction, dest=dest_rank, tag=1)
                
                # If master is also a worker, or needs to process leftover transactions
                # For simplicity, let's assume the master only distributes and collects.
                # If master itself processes, its logic should mirror worker's process.
                
                # Collect results from workers
                received_results_count = 0
                while received_results_count < min(len(transactions_to_process), num_workers_available):
                    try:
                        status = MPI.Status()
                        result_data = self.comm.recv(source=MPI.ANY_SOURCE, tag=2, status=status)
                        source_rank = status.Get_source()
                        print(f"Master received result from worker {source_rank}: {result_data.get('transaction_id')}")
                        
                        # Push the result to the results queue
                        # The server's server.py expects a dictionary that can be converted to a Result object.
                        # The predict_from_transaction below now returns exactly that dictionary.
                        if self.queue_manager.push(results_queue, Message(body=result_data)): # Wrap in Message object
                             print(f"Master pushed result {result_data.get('transaction_id')} to results queue")
                        else:
                            print(f"Master failed to push result {result_data.get('transaction_id')} to results queue (Queue full or error)")
                        received_results_count += 1
                    except Exception as e:
                        print(f"Master error receiving result: {e}")
                        break # Exit on error to prevent infinite loop

        else: # Worker processes (rank > 0)
            while True:
                status = MPI.Status()
                try:
                    # Workers receive the raw transaction dictionary
                    transaction = self.comm.recv(source=0, tag=1, status=status) # waits to receive transaction from master
                    print(f"Worker {self.rank} received transaction: {transaction.get('transaction_id')}")
                except Exception as e:
                    print(f"Worker {self.rank} error receiving transaction: {e}")
                    time.sleep(1) # Wait before trying again
                    continue

                time.sleep(0.5)

                # predict_from_transaction now returns a dict that matches Result.from_dict structure.
                result = self.predict_from_transaction(transaction) # Getting the result from the model (if it's fraudulent or not)
                time.sleep(0.5) # just some buffer time

                self.comm.send(result, dest = 0, tag = 2)   # sends the results to the master process

    def predict_from_transaction(self, transaction):    # This code is the modification of the code from the exercises folder
        # Save customer_id and transaction_id for reference
        customer_id = transaction['customer']['user_id']
        transaction_id = transaction['transaction_id'] # Get transaction_id from the input transaction

        # Preprocess for the model
        df_processed = transaction.copy()
        
        # Ensure 'timestamp' exists for the model input, if the model expects it.
        # For simplicity, let's add a dummy timestamp as a float (Unix timestamp) if needed by your model.
        # Your original snippet had `df_processed.update({'timestamp': datetime.datetime.now()})`
        # which suggests the model might use a timestamp.
        # This part depends on your `fraud_rf_model.pkl` input feature expectations.
        # If your model expects features like 'amount', 'vendor_id', etc., ensure they are present.
        # For this example, we'll assume a simplified set for prediction.
        
        # Mock actual model prediction since the model details are unknown
        import random
        # Assuming predictions are binary (fraudulent or not) and there's a confidence score.
        is_fraudulent = bool(random.getrandbits(1)) # Randomly True or False
        confidence = round(random.uniform(0.5, 0.99), 2) # Random confidence between 0.5 and 0.99

        # Return predictions formatted as expected by the Result class in models.py
        # It needs: result_id, transaction_id, timestamp, is_fraudulent, confidence.
        return {
            "result_id": f"res_{secrets.token_hex(8)}", # Generate a unique ID for the result
            "transaction_id": transaction_id,            # Link back to the original transaction
            "timestamp": datetime.datetime.now().isoformat(), # Current timestamp in ISO 8601 format
            "is_fraudulent": is_fraudulent,
            "confidence": confidence,
        }
    
if __name__ == "__main__":
    conf = load_config()    # Loads data from the config file
    queue_data = conf['QueueManager']
    ml_data = conf['MLModel']

    queue_manager = QueueManager.get_instance(queue_data['path'], queue_data['max_length'], queue_data['save_period_time']) # Creates a QueueManager instance
    ml_service = MLService(queue_manager, ml_data['path'])   # Creates the MLService class instance
    ml_service.process_transactions() # Start processing transactions